# Copyright 2021 Toolchain Labs, Inc. All rights reserved.
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import annotations

import logging
import time

import httpx
from prometheus_client import Counter

from toolchain.base.toolchain_error import ToolchainAssertion

TRANSIENT_ERROR_RETRY = Counter(
    name="toolchain_service_call_transient_error_retry",
    documentation="Count retries for service calls due to transient_errors",
    labelnames=["method", "service", "error_type"],
)

_logger = logging.getLogger(__name__)


class HttpErrorRetryClient(httpx.Client):
    def __init__(self, service_name: str, *, http_error_retries: int = 2, **kwargs):
        super().__init__(**kwargs)
        self._tc_http_retries = http_error_retries or 1
        self._service_name = service_name

    def request(self, *args, **kwargs) -> httpx.Response:
        retries_left = self._tc_http_retries
        while retries_left > 0:
            response = super().request(*args, **kwargs)
            retries_left -= 1
            error_type = self.is_transient_error(response)
            if not error_type:
                break
            request = response.request
            TRANSIENT_ERROR_RETRY.labels(method=request.method, service=self._service_name, error_type=error_type)
            _logger.warning(
                f"transient_error: service={self._service_name} url={request.url} method={request.method} {retries_left=} {error_type=} status={response.status_code}"
            )
            time.sleep(0.3)
        return response

    def is_transient_error(self, response) -> str | None:
        if response.status_code != 503:  # Service N/A
            return None
        if response.headers.get("Content-Type") != "application/json":
            return None
        resp_json = response.json()
        return resp_json["error_type"] if resp_json.get("error") == "transient" else None


class TimeoutRetryHttpClient(httpx.Client):
    def __init__(self, service_name: str, *, timeout_retries: int = 2, **kwargs):
        super().__init__(**kwargs)
        self._tc_timeout_retries = timeout_retries
        self._service_name = service_name

    def request(self, *args, **kwargs) -> httpx.Response:
        retries_left = self._tc_timeout_retries
        while retries_left > 0:
            try:
                return super().request(*args, **kwargs)
            except (httpx.ReadTimeout, httpx.WriteTimeout) as error:
                retries_left -= 1
                self._timeout_error(error, retries_left)
                if retries_left > 0:
                    time.sleep(0.3)
                else:
                    raise
        raise ToolchainAssertion("Unexpected state in TimeoutRetryHttpClient.request")

    def _timeout_error(self, error, retries_left: int) -> None:
        req = error.request
        TRANSIENT_ERROR_RETRY.labels(method=req.method, service=self._service_name, error_type="timeout")
        _logger.warning(
            f"transient_error: service={self._service_name} url={req.url} method={req.method} {retries_left=} error_type='timeout'"
        )

    def is_transient_error(self, response) -> str | None:
        if response.status_code != 503:  # Service N/A
            return None
        if response.headers.get("Content-Type") != "application/json":
            return None
        resp_json = response.json()
        return resp_json["error_type"] if resp_json.get("error") == "transient" else None


def get_http_retry_client(
    *, base_url: str, service_name: str, timeout: int, transport_retries: int, http_error_retries: int
) -> HttpErrorRetryClient:
    """Returns an httpx client that can be used with toolchain internal services client.

    This client will check for transient http errors responses (generated by TransientErrorsMiddleware) and will retry
    the request on those case.
    """
    return HttpErrorRetryClient(
        service_name=service_name,
        http_error_retries=http_error_retries,
        base_url=base_url,
        headers={"User-Agent": f"Toolchain-Internal/{service_name}"},
        timeout=timeout,
        transport=httpx.HTTPTransport(retries=transport_retries),
    )


def get_timeout_retry_client(*, service_name: str, timeout_retries: int, **kwargs) -> TimeoutRetryHttpClient:
    return TimeoutRetryHttpClient(service_name=service_name, timeout_retries=timeout_retries, **kwargs)
