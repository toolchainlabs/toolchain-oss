# Copyright 2021 Toolchain Labs, Inc. All rights reserved.
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Union

from toolchain.base.toolchain_error import ToolchainAssertion
from toolchain.django.auth.constants import AccessTokenAudience, AccessTokenType

_logger = logging.getLogger(__name__)


def load_claims(claims_json: dict) -> Claims:
    if "repo_pk" in claims_json:
        return RepoClaims.from_json_dict(claims_json)
    return UserClaims.from_json_dict(claims_json)


@dataclass(frozen=True)
class BaseClaims:
    """Mandatory jwt claim values common to both users and repos.

    Note that no claims here can be optional, as the constructor (autogenerated by `@dataclass` in `RepoClaims`) adds
    other non-optional arguments.
    """

    CLAIMS_VERSION = 2
    user_api_id: str
    username: str
    audience: AccessTokenAudience
    token_type: AccessTokenType
    token_id: str | None

    def has_audience(self, audience: AccessTokenAudience) -> bool:
        return self.audience.has_all_audiences(audience)

    @property
    def is_access_token(self) -> bool:
        return self.token_type == AccessTokenType.ACCESS_TOKEN

    def as_json_dict(self) -> dict:
        return {
            "user_api_id": self.user_api_id,
            "username": self.username,
            "audience": self.audience.to_claim(),
            "token_type": self.token_type.value,
            "token_id": self.token_id,
        }


@dataclass(frozen=True)
class UserClaims(BaseClaims):
    impersonation_session_id: str | None = None

    @classmethod
    def from_json_dict(cls, json_dict: dict, **kwargs) -> UserClaims:
        audience = AccessTokenAudience.from_api_names(json_dict["audience"])
        return cls(
            user_api_id=json_dict["user_api_id"],
            username=json_dict["username"],
            audience=audience,
            token_type=AccessTokenType(json_dict["token_type"]),
            token_id=json_dict.get("token_id"),
            impersonation_session_id=json_dict.get("impersonation_session_id"),
        )

    @classmethod
    def create_user_claims(cls, claims_dict: dict, audience: AccessTokenAudience) -> UserClaims:
        token_type = AccessTokenType(claims_dict["type"])
        if audience != AccessTokenAudience.FRONTEND_API:
            # This should be checked by the caller, but just in case.
            raise ToolchainAssertion(f"Invalid claims requested only FRONTEND_API is supported got: {audience}")
        return cls(
            user_api_id=claims_dict["toolchain_user"],
            username=claims_dict["username"],
            audience=audience,
            token_type=token_type,
            token_id=claims_dict["jid"] if token_type == AccessTokenType.REFRESH_TOKEN else None,
            impersonation_session_id=claims_dict.get("toolchain_impersonation_session"),
        )

    def as_json_dict(self) -> dict:
        claims_dict = super().as_json_dict()
        claims_dict["impersonation_session_id"] = self.impersonation_session_id
        return claims_dict


@dataclass(frozen=True)
class RepoClaims(BaseClaims):
    customer_pk: str
    repo_pk: str
    restricted: bool  # Restricted claims require extra application level verification before allowing operations (for example, check GH integration)
    impersonated_user_api_id: str | None = None

    @classmethod
    def from_json_dict(cls, json_dict: dict, **kwargs) -> RepoClaims:
        audience = AccessTokenAudience.from_api_names(json_dict["audience"])
        return cls(
            user_api_id=json_dict["user_api_id"],
            username=json_dict["username"],
            audience=audience,
            token_type=AccessTokenType(json_dict["token_type"]),
            token_id=json_dict["token_id"],
            customer_pk=json_dict["customer_pk"],
            repo_pk=json_dict["repo_pk"],
            restricted=json_dict["restricted"],
            impersonated_user_api_id=json_dict["impersonated_user_api_id"],
        )

    @classmethod
    def create_repo_claims(
        cls, claims_dict: dict, audience: AccessTokenAudience, impersonated_user_api_id: str | None
    ) -> RepoClaims:
        # The tokens we already issued are refresh tokens, once they are all replaced, we can remove that code and require claim_dict to have a type prop.
        claim_ver = claims_dict["toolchain_claims_ver"]
        token_type = AccessTokenType.REFRESH_TOKEN if claim_ver == 1 else AccessTokenType(claims_dict["type"])
        if impersonated_user_api_id and not audience.can_impersonate:
            # This should be checked by the caller, but just in case.
            raise ToolchainAssertion("Invalid claims requested.")
        return cls(
            user_api_id=claims_dict["toolchain_user"],
            repo_pk=claims_dict["toolchain_repo"],
            customer_pk=claims_dict["toolchain_customer"],
            username=claims_dict["username"],
            audience=audience,
            token_type=token_type,
            token_id=claims_dict["jid"] if token_type == AccessTokenType.REFRESH_TOKEN else None,
            restricted=claims_dict.get("sub") == "restricted",
            impersonated_user_api_id=impersonated_user_api_id,
        )

    def has_audience(self, audience: AccessTokenAudience) -> bool:
        return self.audience.has_all_audiences(audience)

    @property
    def can_impersonate(self) -> bool:
        return self.audience.can_impersonate

    def as_json_dict(self) -> dict:
        claims_dict = super().as_json_dict()
        claims_dict.update(
            {
                "customer_pk": self.customer_pk,
                "repo_pk": self.repo_pk,
                "restricted": self.restricted,
                "impersonated_user_api_id": self.impersonated_user_api_id,
            }
        )
        return claims_dict


Claims = Union[RepoClaims, UserClaims]
