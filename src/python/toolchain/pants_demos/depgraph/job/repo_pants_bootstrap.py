# Copyright 2021 Toolchain Labs, Inc. All rights reserved.
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import annotations

import logging
import re
import uuid
from dataclasses import dataclass
from glob import glob
from pathlib import Path
from typing import Any

import httpx
import pkg_resources
import tomlkit
from git import Repo

from toolchain.base.fileutil import safe_delete_dir

_logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class RepoInfo:
    commit_sha: str
    branch_name: str


@dataclass
class PantsInitInfo:
    config_file_name: str
    pants_config: dict[str, Any]

    @property
    def pants_version(self) -> str:
        return self.pants_config["GLOBAL"]["pants_version"]


def load_resource(name: str) -> str:
    resource = pkg_resources.resource_string(__name__, f"resources/{name}")
    return resource.decode()


class RepoPantsBootstrapper:
    OTHER_PANTS_FILES = (".pants.rc",)
    _GENERATED_REQS_FILE_MARKERS = ("autogenerated by pip-compile", "generated automatically")
    _LANGUAGE_SPECIFIC_FILES = {
        "java": "jvm.BUILD",
        "scala": "jvm.BUILD",
    }

    @classmethod
    def for_github_ssh(cls, repo: str, branch: str | None, local_repo_dir: Path) -> RepoPantsBootstrapper:
        return cls(repo_name=repo, repo_url=f"git@github.com:{repo}.git", branch=branch, local_repo_dir=local_repo_dir)

    @classmethod
    def for_github_http(cls, repo: str, branch: str | None, local_repo_dir: Path) -> RepoPantsBootstrapper:
        return cls(
            repo_name=repo, repo_url=f"https://github.com/{repo}.git", branch=branch, local_repo_dir=local_repo_dir
        )

    def __init__(self, *, repo_name: str, repo_url: str, branch: str | None, local_repo_dir: Path) -> None:
        self._repo_name = repo_name
        self._repo_url = repo_url
        self._branch = branch
        self._repo_dir = local_repo_dir
        self._random_factor = str(uuid.uuid1())

    def check_repo_accessability(self) -> bool:
        response = httpx.head(url=self._repo_url, follow_redirects=True, timeout=8)
        return response.status_code == 200

    def clone(self) -> RepoInfo:
        safe_delete_dir(self._repo_dir)
        self._repo_dir.mkdir(exist_ok=True, parents=True)
        _logger.info(f"Clone {self._repo_url} to {self._repo_dir}")
        repo = Repo.clone_from(
            url=self._repo_url, to_path=self._repo_dir, multi_options=["--filter=tree:0"], branch=self._branch
        )
        return RepoInfo(commit_sha=repo.head.commit.hexsha, branch_name=self._branch or repo.active_branch.name)

    def _check_other_files(self) -> bool:
        for name in self.OTHER_PANTS_FILES:
            fl = self._repo_dir / name
            if fl.exists():
                _logger.warning(f"pants file: {fl.as_posix()} already exists")
                return True
        return False

    def _get_pants_config(self) -> dict[str, Any]:
        pants_config: dict[str, Any] = tomlkit.parse(load_resource("pants.toml"))
        pattern = pants_config["GLOBAL"]["build_patterns"][0]
        pattern = f"{pattern}{self._random_factor}"
        pants_config["GLOBAL"]["build_patterns"][0] = pattern
        build_fn = pants_config["tailor"]["build_file_name"]
        pants_config["tailor"]["build_file_name"] = f"{build_fn}{self._random_factor}"
        return pants_config

    def add_pants_files(self, skip_files_check: bool) -> PantsInitInfo | None:
        if not skip_files_check and self._check_other_files():
            return None
        _logger.info(f"Add pants to {self._repo_name}: {self._repo_dir}")
        pants_script_data = load_resource("pants_script")
        pants_config = self._get_pants_config()
        pants_script = self._repo_dir / "pants"
        pants_cfg_file = self._repo_dir / f"pants_{self._random_factor}.toml"
        if pants_script.exists():
            _logger.info("pants script exists, replacing it with demo site script")
            pants_script.unlink()
        if pants_script.exists():
            _logger.warning(f"pants script {pants_script.as_posix()} already exists")
            return None
        pants_script.write_text(pants_script_data)
        pants_script.chmod(0o755)  # -rwxr-xr-x
        pants_cfg_file.write_text(tomlkit.dumps(pants_config))
        self._update_git_ignore()
        return PantsInitInfo(config_file_name=pants_cfg_file.name, pants_config=pants_config)

    def _update_git_ignore(self) -> Path:
        # TODO we want to be only add stuff to .git_ignore that is not in it.
        git_ignore_pants = load_resource("gitignore.txt")
        git_ignore_file = self._repo_dir / ".git_ignore"
        if git_ignore_file.exists():
            git_ignore_data = f"{git_ignore_file.read_text()}\n{git_ignore_pants}"
        else:
            git_ignore_data = git_ignore_pants
        git_ignore_file.write_text(git_ignore_data)
        return git_ignore_file

    def add_language_specific_files(self, tailor_output: str, pants_config: dict[str, Any]) -> None:
        """Use the output of `tailor` to conditionally add any language specific files."""
        build_files_to_add = set()
        for language, filename in self._LANGUAGE_SPECIFIC_FILES.items():
            if language in tailor_output:
                build_files_to_add.add(filename)
        for filename in sorted(build_files_to_add):
            root_build_file_data = load_resource(filename)
            build_fn = pants_config["tailor"]["build_file_name"]
            root_build_file = self._repo_dir / build_fn
            _logger.info(f"Adding {root_build_file.as_posix()} from {filename}")
            root_build_file.write_text(root_build_file_data)

    def detect_and_delete_generated_reqs(self) -> int:
        expression = re.compile("|".join(f".*{exp}" for exp in self._GENERATED_REQS_FILE_MARKERS))
        req_files = glob(f"{self._repo_dir}/**/requirement*", recursive=True)
        _logger.info(f"Reqs files: {req_files}")
        deleted_files_count = 0
        for req_file in req_files:
            fl = Path(req_file)
            if not fl.is_file():
                continue
            if expression.match("".join(fl.read_text().splitlines())):
                _logger.info(f"deleting generate file: {fl.as_posix()}")
                fl.unlink()
                deleted_files_count += 1
            else:
                self._maybe_remove_editable_reqs(req_file=fl)
        return deleted_files_count

    def _maybe_remove_editable_reqs(self, req_file: Path) -> bool:
        """Pants can't support requirements that are installed in edit mode ("-e") so we scan requirement files and look
        for those, if we find them we simply remove them.

        Example: https://github.com/StackStorm/st2/blob/419b25da9f45a92fb72549d9c4094e4cb7c6d729/contrib/linux/requirements.txt#L3
        """
        lines = req_file.read_text().splitlines()
        lines_to_keep = [line for line in lines if not line.strip().lower().startswith("-e")]
        if len(lines_to_keep) == len(lines):
            return False
        _logger.info(f"Rewrite {req_file.as_posix()} and eliminate editable reqs")
        req_file.write_text("\n".join(lines_to_keep))
        return True
