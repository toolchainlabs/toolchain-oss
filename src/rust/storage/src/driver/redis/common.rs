// Copyright 2021 Toolchain Labs, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0 (see LICENSE).

use std::future::Future;
use std::time::{Duration, Instant};

use async_trait::async_trait;
use rand::RngCore;
use redis::{Client, Cmd, ErrorKind, FromRedisValue, Pipeline, RedisError, RedisFuture, Value};

use super::traits::{AsRedisConnectionMut, IdentifyRedisConnection};
use crate::driver::redis::traits::RedisConnectionName;
use crate::driver::StorageError;

/// Retrieve a Redis connection from a type that manages Redis connections. This allows client
/// code to abstract over direct connections and connection pools.
#[async_trait]
pub trait ConnectionGetter {
    type Connection: AsRedisConnectionMut + IdentifyRedisConnection + Send + Sync + 'static;

    /// Retrieve a Redis connection. Implementors can optionally support using a read-only
    /// connection if the caller does not need read-write access (i.e., read_write is `false`).
    async fn get_redis_connection(&self, read_write: bool) -> Result<Self::Connection, RedisError>;

    /// Verify that this Redis connection is operating properly.
    async fn verify_connection(&self) -> Result<(), String>;

    /// Update any metrics gauges. This will be called whenever the metrics scraping
    /// admin endpoint is invoked by Prometheus.
    fn update_gauges(&self) {}
}

/// Represents a Redis backend with primary and read-only endpoints. Generally a connection
/// pool will be used but any implementation of `ConnectionGetter` suffices.
#[derive(Clone)]
pub struct RedisBackend<P> {
    primary_pool: P,
    read_only_pool: Option<P>,
    name: String,
    primary_probability: Option<usize>,
}

impl<P> RedisBackend<P>
where
    P: ConnectionGetter + Send + Sync + 'static,
{
    pub fn new(
        name: impl Into<String>,
        primary_pool: P,
        read_only_pool: Option<P>,
        primary_probability: Option<usize>,
    ) -> Self {
        RedisBackend {
            primary_pool,
            read_only_pool,
            name: name.into(),
            primary_probability,
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }
}

#[async_trait]
impl<P> ConnectionGetter for RedisBackend<P>
where
    P: ConnectionGetter + Clone + Send + Sync + 'static,
{
    type Connection = <P as ConnectionGetter>::Connection;

    async fn get_redis_connection(&self, read_write: bool) -> Result<Self::Connection, RedisError> {
        let start_time = Instant::now();
        let backend_name = self.name().to_owned();

        let (pool, pool_name) = match (read_write, self.read_only_pool.as_ref()) {
            (false, Some(read_only_pool)) => {
                // Choose whether to send the traffic to the read-only pool or the primary
                // pool based on the configured probability. This is necessary to allow the
                // primary to observe actual read queries so that its LRU usage information
                // is accurate. (At least for Redis, read-only replicas do not provide
                // feedback to the primary on how keys are being accessed.)
                let use_primary = if let Some(prob) = self.primary_probability {
                    let choice = (rand::thread_rng().next_u32() % 1000) as usize;
                    choice < prob
                } else {
                    false
                };

                if use_primary {
                    (self.primary_pool.clone(), "primary")
                } else {
                    (read_only_pool.clone(), "read_only")
                }
            }
            _ => (self.primary_pool.clone(), "primary"),
        };

        let result = pool.get_redis_connection(read_write).await;

        let elapsed = start_time.elapsed();
        metrics::histogram!(
            "toolchain_storage_redis_get_connection_duration_seconds",
            elapsed,
            "result" => if result.is_ok() { "ok "} else { "error" },
            "redis_backend" => backend_name,
            "redis_endpoint" => pool_name,
        );

        result
    }

    async fn verify_connection(&self) -> Result<(), String> {
        self.primary_pool.verify_connection().await.map_err(|err| {
            format!(
                "Unable to verify connection to primary pool of backend `{}` with INFO command: {}",
                &self.name, err
            )
        })?;

        if let Some(pool) = &self.read_only_pool {
            pool.verify_connection().await.map_err(|err| {
                format!(
                    "Unable to verify connection to read-only pool of backend `{}` with INFO command: {}",
                    &self.name, err
                )
            })?;
        }

        Ok(())
    }

    /// Update any gauge metrics generated by this `RedisBackend`.
    fn update_gauges(&self) {
        self.primary_pool.update_gauges();
        if let Some(pool) = self.read_only_pool.as_ref() {
            pool.update_gauges();
        }
    }
}

/// Send INFO command to Redis to verify a client is connected.
pub(crate) async fn send_info_cmd<C>(
    conn: &mut C,
    driver_label: &'static str,
) -> Result<(), RedisError>
where
    C: AsRedisConnectionMut + IdentifyRedisConnection + Send + Sync,
{
    let info_cmd = redis::cmd("INFO");
    let info_fut = send_one_query::<_, ()>(conn, "INFO", driver_label, &info_cmd);
    match tokio::time::timeout(Duration::from_secs(5), info_fut).await {
        Ok(Ok(_)) => Ok(()),
        Ok(Err(err)) => Err(err),
        Err(_) => Err(RedisError::from((
            ErrorKind::ClusterDown,
            "timed-out",
            "Timed out while sending INFO command to server.".to_string(),
        ))),
    }
}

/// Make a call to the Redis backend and emit metrics.
fn send_one_query<'a, C, T>(
    conn: &'a mut C,
    cmd_label: &'static str,
    driver_label: &'static str,
    cmd: &'a Cmd,
) -> impl Future<Output = Result<T, RedisError>> + 'a
where
    C: AsRedisConnectionMut + IdentifyRedisConnection + Send + Sync,
    T: FromRedisValue,
{
    let conn_name = conn.identify_redis_connection();

    async move {
        metrics::counter!(
            "toolchain_storage_redis_requests_total",
            1,
            "driver" => driver_label,
            "redis_backend" => conn_name.backend.clone(),
            "redis_endpoint" => conn_name.endpoint,
            "redis_cmd" => cmd_label,
        );

        let start_time = Instant::now();
        let result = cmd.query_async(conn.as_redis_conn_mut()).await;
        let elapsed = start_time.elapsed();

        metrics::histogram!(
            "toolchain_storage_redis_requests_duration_seconds",
            elapsed,
            "driver" => driver_label,
            "redis_backend" => conn_name.backend.clone(),
            "redis_endpoint" => conn_name.endpoint,
            "redis_cmd" => cmd_label,
        );
        result
    }
}

/// Make a call to Redis backend and emit metrics. Handles retrying the command once if the
/// connection is dropped or refused. The command must be idempotent.
pub fn redis_query<'a, C, T>(
    conn: &'a mut C,
    cmd_label: &'static str,
    driver_label: &'static str,
    cmd: &'a Cmd,
) -> impl Future<Output = Result<T, StorageError>> + 'a
where
    C: AsRedisConnectionMut + IdentifyRedisConnection + Send + Sync,
    T: FromRedisValue,
{
    async move {
        let mut result = send_one_query(conn, cmd_label, driver_label, cmd).await;
        if let Err(ref err) = result {
            if err.is_connection_dropped() || err.is_connection_refusal() {
                // If the connection is dropped or refused, retry the request once since the
                // `ConnectionManager` will be reconnecting.
                metrics::counter!("toolchain_storage_redis_retried_requests_total", 1,
                    "driver" => driver_label, "redis_cmd" => cmd_label);
                result = send_one_query(conn, cmd_label, driver_label, cmd).await
            }
        }
        result.map_err(StorageError::from)
    }
}

/// Make a call to the Redis backend and emit metrics.
fn send_one_pipeline<'a, C, T>(
    conn: &'a mut C,
    cmd_label: &'static str,
    driver_label: &'static str,
    pipeline: &'a Pipeline,
) -> impl Future<Output = Result<T, RedisError>> + 'a
where
    C: AsRedisConnectionMut + IdentifyRedisConnection + Send + Sync,
    T: FromRedisValue,
{
    let conn_name = conn.identify_redis_connection();

    async move {
        metrics::counter!(
            "toolchain_storage_redis_requests_total",
            1,
            "driver" => driver_label,
            "redis_backend" => conn_name.backend.clone(),
            "redis_endpoint" => conn_name.endpoint,
            "redis_cmd" => cmd_label,
        );
        let start_time = Instant::now();
        let result = pipeline.query_async(conn.as_redis_conn_mut()).await;
        let elapsed = start_time.elapsed();

        metrics::histogram!(
            "toolchain_storage_redis_requests_duration_seconds",
            elapsed,
            "driver" => driver_label,
            "redis_backend" => conn_name.backend.clone(),
            "redis_endpoint" => conn_name.endpoint,
            "redis_cmd" => cmd_label
        );

        result
    }
}

/// Make a call to Redis backend and emit metrics. Handles retrying the command once if the
/// connection is dropped or refused. The command must be idempotent.
pub fn redis_pipeline<'a, C, T>(
    conn: &'a mut C,
    cmd_label: &'static str,
    driver_label: &'static str,
    pipeline: &'a Pipeline,
) -> impl Future<Output = Result<T, StorageError>> + 'a
where
    C: AsRedisConnectionMut + IdentifyRedisConnection + Send + Sync,
    T: FromRedisValue,
{
    async move {
        let mut result = send_one_pipeline(conn, cmd_label, driver_label, pipeline).await;
        if let Err(ref err) = result {
            if err.is_connection_dropped() || err.is_connection_refusal() {
                // If the connection is dropped or refused, retry the request once since the
                // `ConnectionManager` will be reconnecting.
                let conn_name = conn.identify_redis_connection();

                metrics::counter!(
                    "toolchain_storage_redis_retried_requests_total",
                    1,
                    "driver" => driver_label,
                    "redis_backend" => conn_name.backend.clone(),
                    "redis_endpoint" => conn_name.endpoint,
                    "redis_cmd" => cmd_label,
                );
                result = send_one_pipeline(conn, cmd_label, driver_label, pipeline).await
            }
        }
        result.map_err(StorageError::from)
    }
}

/// Wrap `redis::Client` to implement `ConnectionGetter` and `IdentifyRedisConnection`.
#[derive(Clone)]
pub struct ClientWrapper {
    client: Client,
    conn_name: RedisConnectionName,
}

impl ClientWrapper {
    pub fn new(client: Client, conn_name: RedisConnectionName) -> Self {
        Self { client, conn_name }
    }
}

pub struct ConnectionWrapper {
    conn: redis::aio::Connection,
    conn_name: RedisConnectionName,
}

#[async_trait]
impl ConnectionGetter for ClientWrapper {
    type Connection = ConnectionWrapper;

    async fn get_redis_connection(
        &self,
        _read_write: bool,
    ) -> Result<Self::Connection, RedisError> {
        let conn = self.client.get_tokio_connection().await?;
        Ok(ConnectionWrapper {
            conn,
            conn_name: self.conn_name.clone(),
        })
    }

    async fn verify_connection(&self) -> Result<(), String> {
        Ok(())
    }
}

impl redis::aio::ConnectionLike for ConnectionWrapper {
    fn req_packed_command<'a>(&'a mut self, cmd: &'a Cmd) -> RedisFuture<'a, Value> {
        self.conn.req_packed_command(cmd)
    }

    fn req_packed_commands<'a>(
        &'a mut self,
        cmd: &'a Pipeline,
        offset: usize,
        count: usize,
    ) -> RedisFuture<'a, Vec<Value>> {
        self.conn.req_packed_commands(cmd, offset, count)
    }

    fn get_db(&self) -> i64 {
        0
    }
}

impl AsRedisConnectionMut for ConnectionWrapper {
    type Target = redis::aio::Connection;

    fn as_redis_conn_mut(&mut self) -> &mut Self::Target {
        &mut self.conn
    }
}

impl IdentifyRedisConnection for ConnectionWrapper {
    fn identify_redis_connection(&self) -> RedisConnectionName {
        self.conn_name.clone()
    }
}

#[cfg(test)]
mod tests {
    use std::io;

    use redis::RedisError;

    use super::super::testutil::{MockCommand, MockRedisConnection};
    use super::redis_query;

    #[tokio::test]
    async fn retries_once_on_connection_drop() {
        let mut conn = MockRedisConnection::new(vec![
            MockCommand::new::<_, String>(
                redis::cmd("GET").arg("foo"),
                Err(RedisError::from(io::Error::from(io::ErrorKind::BrokenPipe))),
            ),
            MockCommand::new(redis::cmd("GET").arg("foo"), Ok("bar")),
        ]);

        let value: String = redis_query(&mut conn, "GET", "test", redis::cmd("GET").arg("foo"))
            .await
            .unwrap();
        assert_eq!(value, "bar");
    }
}
